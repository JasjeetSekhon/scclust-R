% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utilities.R
\name{check_clustering}
\alias{check_clustering}
\title{Check the validity of a clustering.}
\usage{
check_clustering(clustering, size_constraint = NULL, type_labels = NULL,
  type_constraints = NULL)
}
\arguments{
\item{clustering}{a \code{scclust} object containing an existing non-empty clustering.}

\item{size_constraint}{an integer with the required minimum cluster size. If \code{NULL},
only the type constraints will be checked.}

\item{type_labels}{a factor or integer containing the type of each data point. May be \code{NULL} when}

\item{type_constraints}{a named vector containing the type specific size constraints. If \code{NULL},
only the overall constraint will be checked.}
}
\value{
Returns \code{TRUE} if \code{clustering} satisfies the size constraint, and \code{FALSE}
        if it does not. Throws an error if \code{clustering} is an invalid clustering.
}
\description{
\code{check_clustering} checks so the inputted clustering satisfies the specified size
constraint.
}
\examples{
# Each cluster contains at least two data
# points; it's valid for `size_constraint == 2`.
my_clust_obj1 <- scclust(c("A", "A", "B", "C",
                                  "B", "C", "C", "A",
                                  "B", "B"))
check_clustering(my_clust_obj1, 2)
# > TRUE


# One cluster contains only one point. This is
# an invalid clustering for `size_constraint == 2`.
my_clust_obj2 <- scclust(c("A", "A", "B", "C",
                                  "B", "C", "C", "A",
                                  "B", "B", "D"))
check_clustering(my_clust_obj2, 2)
# > FALSE


# `my_clust_obj1` doesn't contain clusters with
# at least 5 units, it's invalid for `size_constraint == 2`.
check_clustering(my_clust_obj1, 5)
# > FALSE


# Clustering
my_clust_obj3 <- scclust(c(1, 1, 2, 3, 2, 3, 3, 1, 2, 2))

# Data point types
my_types <- factor(c("x", "y", "y", "z", "z", "x", "y", "z", "x", "x"))


# Check whether each cluster contains one point of each
# of type "x", "y" and "z".
check_clustering(my_clust_obj3,
                 NULL,
                 my_types,
                 c("x" = 1, "y" = 1, "z" = 1))
# > TRUE


# Check whether each cluster contains one point of each
# of type "x", "y" and "z" and at least three points in total.
check_clustering(my_clust_obj3,
                 3,
                 my_types,
                 c("x" = 1, "y" = 1, "z" = 1))
# > TRUE


# Check whether each cluster contains five data points of type "y".
check_clustering(my_clust_obj3,
                 NULL,
                 my_types,
                 c("y" = 5))
# > FALSE


# Check whether each cluster contains one data point of
# both "x" and "z" and at least three points in total.
check_clustering(my_clust_obj3,
                 3,
                 my_types,
                 c("x" = 1, "z" = 1))
# > TRUE


# Using integers as type labels.
my_int_types <- c(1L, 2L, 2L, 3L, 3L, 1L, 2L, 3L, 1L, 1L)
check_clustering(my_clust_obj3,
                 NULL,
                 my_int_types,
                 c("1" = 1, "2" = 1, "3" = 1))
# > TRUE

}
\seealso{
See \code{\link{sc_clustering}} for details on
         how to specific type labels and constraints.
}
