% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distances.R
\name{make_distances}
\alias{make_distances}
\title{Construct distance metric object.}
\usage{
make_distances(data, id_variable = NULL, dist_variables = NULL,
  normalize = NULL, weights = NULL)
}
\arguments{
\item{data}{a matrix or data frame containing the data points between distances should be derived.}

\item{id_variable}{optional IDs of the data points.
If \code{id_variable} is a single string and \code{data} is a data frame, the
corresponding column in \code{data} will be taken as IDs. That column will be
excluded from \code{data} when constructing distances. If \code{id_variable} is
\code{NULL}, the IDs are set to \code{1:nrow(data)}. Otherwise, \code{id_variable}
must be of length \code{nrow(data)} and will be used directly as IDs.}

\item{dist_variables}{optional names of the columns in \code{data} that should
be used when constructing distances. If \code{dist_variables} is \code{NULL},
all columns will be used (net of eventual column specified by \code{id_variable}).
If \code{data} is a matrix, \code{dist_variables} must be \code{NULL}.}

\item{normalize}{optional normalization of the data prior to distance construction. If \code{normalize}
is \code{NULL} or \code{"none"}, no normalization will be done (effectively setting \code{normalize}
to the identity matrix). If \code{normalize} is \code{"mahalanobize"}, normalization will be
done with \code{var(data)} (i.e., resulting in Mahalanobis distances). If \code{normalize} is
\code{"studentize"}, normalization is done with the diagonal of \code{var(data)}. If \code{normalize}
is a matrix, it will be used in the normalization. If \code{normalize} is a vector, a diagonal matrix
with the supplied vector as its diagonal will be used. The matrix used for normalization must be
positive-semidefinite.}

\item{weights}{optional weighting of the data prior to distance construction. If \code{normalize} is \code{NULL}
no weighting will be done (effectively setting \code{weights} to the identity matrix). If \code{weights}
is a matrix, that will be used in the weighting. If \code{normalize} is a vector, a diagonal matrix
with the supplied vector as its diagonal will be used. The matrix used for weighting must be
  positive-semidefinite.}
}
\value{
\code{make_distances} returns a distance object to be used when calling the clustering, blocking or matching
        functions.
}
\description{
\code{make_distances} constructs Euclidean distances to be used in clustering
problems (including blocking and matching problems). It optionally normalize and
weights the inputted data so to achieve, e.g., Mahalanobis distances or
normalized Euclidean distances.
}
\details{
Let \eqn{x} and \eqn{y} be two data points in \code{data} described by two vectors. \code{make_distances}
uses the following metric to derive the distance between \eqn{x} and \eqn{y}:

\deqn{\sqrt{(x - y) N^{-0.5} W N^{-0.5} (x - y)}}{\sqrt((x - y) * N^-0.5 * W * N^-0.5 * (x - y))}

where \eqn{N^{-0.5}}{N^-0.5} is the Cholesky decomposition of the inverse of the matrix speficied by \code{normalize}, and \eqn{W}
is matrix speficied by \code{weights}.

When \code{normalize} is \code{var(data)} (i.e., using the \code{"mahalanobize"} option), this
derives the (weighted) Mahalanobis distances. When \code{normalize} is \code{diag(var(data))} (i.e., using
the \code{"studentize"} option), this will effective divide each column by its variance leading to (weighted) normalized
Euclidean distances. If \code{normalize} is the identity matrix (i.e., using the \code{"none"} or \code{NULL} option), this
derives the (weighted) Euclidean distances.
}

